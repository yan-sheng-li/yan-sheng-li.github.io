(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{493:function(t,v,_){"use strict";_.r(v);var a=_(1),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"关于索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于索引"}},[t._v("#")]),t._v(" 关于索引")]),t._v(" "),v("blockquote",[v("p",[t._v("索引在数据库中类似于书的目录，可以帮助你快速找到想要的信息，而不用翻遍整本书。让我们看看索引的作用和它的优缺点。\n什么是索引？")])]),t._v(" "),v("p",[t._v("索引是一种数据结构，用于快速查找数据库表中的记录。它们类似于书的目录，可以指引你到正确的页码，而不需要逐页翻找。数据库中，索引存储在一个单独的地方，指向表中的实际数据。")]),t._v(" "),v("h2",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),v("h3",{attrs:{id:"加快查询速度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加快查询速度"}},[t._v("#")]),t._v(" 加快查询速度")]),t._v(" "),v("p",[t._v("举例：假设你有一个很大的书籍数据库，需要查找一本特定的书。如果没有索引，你需要逐条检查每本书的信息，直到找到目标。使用索引，就像直接翻到书的目录找到页码一样，可以迅速定位到你需要的书。")]),t._v(" "),v("h3",{attrs:{id:"提高排序和分组效率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提高排序和分组效率"}},[t._v("#")]),t._v(" 提高排序和分组效率")]),t._v(" "),v("p",[t._v("举例：如果你需要按书名排序或按作者分组，有索引会让这些操作变得更快，因为索引已经对数据进行了部分排序。")]),t._v(" "),v("h3",{attrs:{id:"加快表连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加快表连接"}},[t._v("#")]),t._v(" 加快表连接")]),t._v(" "),v("p",[t._v("举例：当你需要从多个表中获取相关数据时，索引可以加速这些表之间的连接，类似于用交叉引用找到相关的章节。")]),t._v(" "),v("h2",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),v("h3",{attrs:{id:"占用额外空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#占用额外空间"}},[t._v("#")]),t._v(" 占用额外空间：")]),t._v(" "),v("p",[t._v("举例：索引是额外的数据结构，它们需要占用额外的存储空间。就像书的目录和索引页也占用了书中的一些页码。")]),t._v(" "),v("h3",{attrs:{id:"影响写操作的速度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#影响写操作的速度"}},[t._v("#")]),t._v(" 影响写操作的速度：")]),t._v(" "),v("p",[t._v("举例：每当你向数据库中添加、删除或更新记录时，索引也需要同步更新。这就像每次添加新内容时还要更新目录，增加了额外的工作量。")]),t._v(" "),v("h3",{attrs:{id:"可能导致索引失效"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可能导致索引失效"}},[t._v("#")]),t._v(" 可能导致索引失效：")]),t._v(" "),v("p",[t._v("举例：如果索引选择不当或没有维护好，查询优化器可能不会使用索引，从而失去了加速查询的优势。")]),t._v(" "),v("h2",{attrs:{id:"分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),v("ul",[v("li",[t._v("主键索引：")])]),t._v(" "),v("p",[t._v("用于唯一标识每一条记录，主键索引的值不允许重复且不能为空，并且一个表只能有一个主键索引。")]),t._v(" "),v("ul",[v("li",[t._v("唯一索引：")])]),t._v(" "),v("p",[t._v("用于保证索引列的值唯一，允许为空值，但是一个表可以有多个唯一索引。")]),t._v(" "),v("ul",[v("li",[t._v("普通索引：")])]),t._v(" "),v("p",[t._v("没有唯一性限制，允许重复值和空值，是最基本的索引类型。")]),t._v(" "),v("ul",[v("li",[t._v("组合索引：")])]),t._v(" "),v("p",[t._v("在多个字段上创建的索引，可以包含多个列。组合索引可以提高多列查询的性能，但查询条件必须符合最左前缀原则，即查询从左到右使用组合索引中的列。")]),t._v(" "),v("h2",{attrs:{id:"注意"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意")]),t._v(" "),v("ul",[v("li",[t._v("选择适当的列：")])]),t._v(" "),v("p",[t._v("根据实际查询需求和数据特点，选择合适的列作为索引列。通常情况下，选择经常被用于查询条件、排序或聚合操作的列作为索引列可以获得更好的性能。")]),t._v(" "),v("ul",[v("li",[t._v("避免过多的索引：")])]),t._v(" "),v("p",[t._v("过多的索引会增加存储空间的开销，并且在数据写入时需要维护多个索引结构，导致性能下降。因此，只创建必要的索引，避免不必要的冗余索引。")]),t._v(" "),v("ul",[v("li",[t._v("考虑联合索引：")])]),t._v(" "),v("p",[t._v("对于多个列的组合查询条件，可以考虑创建复合索引。复合索引可以覆盖多个列，减少查询时需要访问的索引数量，提高查询效率。")]),t._v(" "),v("ul",[v("li",[t._v("注意索引的顺序：")])]),t._v(" "),v("p",[t._v("对于多列索引，考虑索引的顺序。将最常用的列放在索引的前面，以提高查询性能。")]),t._v(" "),v("ul",[v("li",[t._v("使用合适的数据类型：")])]),t._v(" "),v("p",[t._v("选择合适的数据类型可以减小索引的大小，提高索引的效率。尽量避免使用过长或过大的数据类型作为索引列。")])])}),[],!1,null,null,null);v.default=s.exports}}]);